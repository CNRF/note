

## 为什么需要主从复制？

1. 在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。
2. 做数据的热备
3. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

## MySQL 主从复制概念

MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

## MySQL 主从复制主要用途

- **读写分离**

	在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，**即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。**

- **数据实时备份，当系统中某个节点出现故障的时候，方便切换**

- **高可用HA**

- **架构扩展**

	随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。

## MySQL主从形式

### 一主一从

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130707.png)

### 一主多从，提高系统的读性能

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130804.png)

一主一从和一主多从是最常见的主从架构，**实施起来简单并且有效，不仅可以实现HA，而且还能读写分离，进而提升集群的并发能力。**

### 多主一从 （从5.7开始支持）

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130643.png)

多主一从可以将多个mysql数据库备份到一台存储性能比较好的服务器上。

### 双主复制

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130947.png)

双主复制，也就是互做主从复制，每个master既是master，又是另外一台服务器的slave。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。

### 级联复制

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130599.png)

级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。

## MySQL 主从复制原理

MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130674.png)

-  **主节点 binary log dump 线程作用**

当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。

- **从节点I/O线程作用**

当从节点上执行`start slave`命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。

-  **从节点SQL线程作用**

SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。



对于每一个主从连接，都需要三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。

## MySQL主从复制的过程

要实施复制，首先必须打开Master 端的binary log（bin-log）功能，否则无法实现。因为整个复制过程实际上就是Slave 从Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050130111.png)

1. 从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），**从库并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；**
2. 从库的IO线程和主库的dump线程建立连接。
3. 从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。
4. 主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；
5. 从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
6. 从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge

## MySQL 主从复制模式

MySQL 主从复制**默认是异步的模式**。MySQL增删改操作会全部记录在binary log中，当slave节点连接master时，会主动从master处获取最新的bin log文件。并把bin log中的sql relay。

### 异步模式（mysql async-mode）

异步模式如下图所示，这种模式下，主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050131491.png)

### 半同步模式(mysql semi-sync)

这种模式下**主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交**；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，**binlog至少传输到了一个从节点上，不能保证从节点将此事务更新到db中**。性能上会有一定的降低，响应时间会变长。如下图所示：

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050131498.png)

### 全同步模式

全同步模式是指主节点和**从节点全部执行了commit并确认**才会向客户端返回成功。

## MySQL的复制机制

### binlog记录模式

MySQL 主从复制有三种方式：基于SQL语句的复制（statement-based replication，SBR），基于行的复制（row-based replication，RBR)，混合模式复制（mixed-based replication,MBR)。对应的binlog文件的格式也有三种：STATEMENT,ROW,MIXED。

1.  Statement-base Replication (SBR)就是记录sql语句在bin log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。
2. Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更。
3. Mixed-format Replication(MBR)，MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。

### GTID复制模式

在MySQL 5.6里面，不用再找binlog和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，**MySQL会通过内部机制GTID自动找点同步。**

#### 基于GTID复制实现的工作原理

1. 主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。
2. 从节点的I/O线程将变更的bin log，写入到本地的relay log中。
3. SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（**所以MySQL从节点必须要开启binary log**）。
4. 如果有记录，说明该GTID的事务已经执行，从节点会忽略。
5. 如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。
6. 在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。

## mysql主从同步延时分析

mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，**当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。**

**解决方案**：

1. 业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。
2. 单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库
3. 服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。
4. 不同业务的mysql物理上放在不同机器，分散压力。
5. 使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。
6. 使用更加强劲的硬件设备

**mysql5.7之后使用MTS并行复制技术**

### 多线程复制MTS

在MYSQL5.6版本中，多线程复制基于schema来实现，将多个数据库下的事务按照数据库拆分到多个线程上执行，保证数据库级别的事务一致性。

在MYSQL5.7版本后，多线程复制基于主库上并发信息来实现，主库上并发提交的事务不存在事务冲突，在从库上拆分到多个线程执行，保证实例级别的事务一致性。

#### MySQL5.6 基于schema的并行复制

slave-parallel-type=DATABASE(不同库的事务，没有锁冲突),并行复制的目的就是要让slave尽可能的多线程跑起来，当然基于库级别的多线程也是一种方式(不同库的事务，没有锁冲突)。

**优点：**实现相对来说简单，对用户来说使用起来也简单

**缺点：** 由于是基于库的，那么并行的粒度非常粗，现在很多公司的架构是一库一实例，针对这样的架构，5.6的并行复制无能为力。当然还有就是主从事务的先后顺序，对于5.6也是个大问题

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050131305.png)

MySQL 5.6版本开启并行复制功能，那么SQL线程就变为了coordinator线程，coordinator线程主要负责以前两部分的内容：

- 若判断可以并行执行，那么选择worker线程执行事务的二进制日志
- 若判断不可以并行执行，如该操作是DDL，亦或者是事务跨schema操作，则等待所有的worker线程执行完成之后，再执行当前的日志

这意味着coordinator线程并不是仅将日志发送给worker线程，自己也可以回放日志，但是所有可以并行的操作交付由worker线程完成。coordinator线程与worker是典型的生产者与消费者模型。

上述机制实现了基于schema的并行复制存在两个问题，首先是crash safe功能不好做，因为可能之后执行的事务由于并行复制的关系先完成执行，那么当发生crash的时候，这部分的处理逻辑是比较复杂的。从代码上看，5.6这里引入了Low-Water-Mark标记来解决该问题，从设计上看（WL#5569），其是希望借助于日志的幂等性来解决该问题，不过5.6的二进制日志回放还不能实现幂等性。另一个最为关键的问题是这样设计的并行复制效果并不高，如果用户实例仅有一个库，那么就无法实现并行回放，甚至性能会比原来的单线程更差。而单库多表是比多库多表更为常见的一种情形。

#### MySQL 5.7基于组提交的并行复制

MySQL 5.7才可称为真正的并行复制，这其中最为主要的原因就是slave服务器的回放与主机是一致的即master服务器上是怎么并行执行的slave上就怎样进行并行回放。不再有库的并行复制限制，对于二进制日志格式也无特殊的要求（基于库的并行复制也没有要求）。从MySQL官方来看，其并行复制的原本计划是支持表级的并行复制和行级的并行复制，行级的并行复制通过解析ROW格式的二进制日志的方式来完成，WL#4648。但是最终出现给小伙伴的确是在开发计划中称为：MTS: Prepared transactions slave parallel applier，可见：WL#6314。该并行复制的思想最早是由MariaDB的Kristain提出，并已在MariaDB 10中出现，相信很多选择MariaDB的小伙伴最为看重的功能之一就是并行复制。

> MySQL 5.7并行复制的思想简单易懂，一言以蔽之：<font color=red>一个组提交的事务都是可以并行回放，因为这些事务都已进入到事务的prepare阶段，则说明事务之间没有任何冲突（否则就不可能提交）。</font>

为了兼容MySQL 5.6基于库的并行复制，5.7引入了新的变量slave-parallel-type，其可以配置的值有：

- DATABASE：默认值，基于库的并行复制方式
- LOGICAL_CLOCK：基于组提交的并行复制方式

##### 支持并行复制的GTID（5.7之后支持）

在MySQL 5.7版本中，其设计方式是将组提交的信息存放在GTID中。那么如果用户没有开启GTID功能，即将参数gtid_mode设置为OFF，MySQL 5.7又引入了称之为Anonymous_Gtid的二进制日志event类型，意味着在**MySQL 5.7版本中即使不开启GTID，每个事务开始前也是会存在一个Anonymous_Gtid，而这GTID中就存在着组提交的信息。**

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050131100.png)

然而，通过上述的SHOW BINLOG EVENTS，我们并没有发现有关组提交的任何信息。但是通过mysqlbinlog工具，用户就能发现组提交的内部信息：

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050132312.png)

可以发现较之原来的二进制日志内容多了last_committed和sequence_number，last_committed表示事务提交的时候，上次事务提交的编号，如果**事务具有相同的last_committed，表示这些事务都在一组内，可以进行并行的回放。例如上述last_committed为0的事务有6个，表示组提交时提交了6个事务，而这6个事务在从机是可以进行并行回放的。**