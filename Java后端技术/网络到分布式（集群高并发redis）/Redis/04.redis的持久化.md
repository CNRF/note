##### 1. redis的持久化方式

1. RDB持久化

	原理是将**Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化**

2.   AOF持久化

	原理是将**Reids的操作日志以追加的方式写入文件**
	
	[两种持久化方式区别](https://www.cnblogs.com/zxs117/p/11242026.html)
	
	二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。不过生产环境其实更多都是二者结合使用的。
	
	

##### 2.RDB持久化

**原理** :在liunx系统系统中，**进程之间的数据是隔离的**，在使用export的环境变量，**父子进程的修改都不会影响到其他进程的数据**

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是**fork一个子进程**，先将**数据集写入临时文件**，写入成功后，再替换之前的文件，用二进制压缩存储。

![](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050035081.png)

###### 2.1 RDB的优缺点

**优点**： 

1. **还原速度快**（类似java的对象序列化，可快速还原）
2. **整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的**。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。

**弊端**：

1. 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么**RDB将不是一个很好的选择。因为系统一旦在定时持久化完成之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失**。
2.  由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，**如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。**

> fork命令只是创建进程，并不会在此时进行复制，因此创建进程的速度变快
>
> fork出来的父子进程具有 **相同但是独立的地址空间**因为父进程和子进程是独立的进程，他们都有自己私有的地址空间，当父进程或者子进程单独改变时，不会影响到彼此，类似于c++的写实拷贝的形式自建一个副本
>
> [fork命令详细说明](https://blog.csdn.net/weixin_40853073/article/details/81873398?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=4254810a-f10f-43c5-8965-6b775b5a3682&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)

![image-20210221233300160](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050035565.png)

![image-20210303093910862](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050035098.png)

![image-20210226151042967](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050036420.png)

##### 3. AOF持久化

AOF持久化以**日志的形式**记录服务器所处理的**每一个写、删除操作**，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

> 当redis同时开启RDB和AOF备份，redis恢复是只会依据AOF的备份（AOF的数据丢失较少）

![image-20210221233312115](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050036671.png)

![image-20210226151129085](https://raw.githubusercontent.com/CNRF/noteImage/main/image/202302050036209.png)

###### 3.1 AOF的优缺点

**优点**：

1). 该机制可以带来**更高的数据安全性，即数据持久性**。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。

2). 由于该机制对日志文件的**写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容**。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以**通过redis-check-aof工具来帮助我们解决数据一致性的问题。**

3). 如果**日志过大，Redis可以自动启用rewrite机制**。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。

> redis4.0以前：rewrite其实是删除抵消的命令（创建和删除），合并重复的命名。最终会生成重复命令
>
> redis4.0以后：将老的数据RDB到AOF中，将增量的以指令的方式append到aof中（实际就是混合RDB+AOF的持久化方式）

4). **AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建**。

**缺点**：

1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。**RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。**

2). 根据同步策略的不同，**AOF在运行效率上往往会慢于RDB**。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。

